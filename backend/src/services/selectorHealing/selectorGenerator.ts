/**
 * Selector Generator Service
 *
 * Generates resilient selectors with fallbacks for recorded elements.
 */

import {
    SelectorCandidate,
    ResilientSelector,
    CapturedElement,
    ElementFingerprint,
    SELECTOR_STABILITY
} from './types';

/**
 * Generate resilient selector with fallbacks for an element
 */
export function generateResilientSelector(element: CapturedElement): ResilientSelector {
    const candidates: SelectorCandidate[] = [];

    // 1. TestId (highest priority)
    if (element.testId) {
        candidates.push({
            strategy: 'testId',
            selector: `testId "${element.testId}"`,
            playwrightSelector: `[data-testid="${element.testId}"]`,
            confidence: 100,
            isStable: true,
            description: 'Test ID - Most reliable, explicit test hook',
        });
    }

    // 2. Role with accessible name
    const role = element.role || inferRole(element);
    if (role) {
        const name = element.ariaLabel || (element.innerText?.slice(0, 50).trim());
        if (name) {
            candidates.push({
                strategy: 'role',
                selector: `${role} "${name}"`,
                playwrightSelector: `role=${role}[name="${name}"]`,
                confidence: 90,
                isStable: true,
                description: 'ARIA Role with name - Semantic and accessible',
            });
        } else {
            candidates.push({
                strategy: 'role',
                selector: `role "${role}"`,
                playwrightSelector: `role=${role}`,
                confidence: 70,
                isStable: true,
                description: 'ARIA Role - Semantic',
            });
        }
    }

    // 3. Label (for form elements)
    if (element.ariaLabel) {
        candidates.push({
            strategy: 'label',
            selector: `label "${element.ariaLabel}"`,
            playwrightSelector: `label=${element.ariaLabel}`,
            confidence: 85,
            isStable: true,
            description: 'Label - Form element association',
        });
    }

    // 4. Placeholder
    if (element.placeholder) {
        candidates.push({
            strategy: 'placeholder',
            selector: `placeholder "${element.placeholder}"`,
            playwrightSelector: `placeholder=${element.placeholder}`,
            confidence: 80,
            isStable: false, // Placeholders may change
            description: 'Placeholder - Input hint text',
        });
    }

    // 5. Alt text (for images)
    if (element.alt) {
        candidates.push({
            strategy: 'altText',
            selector: `alt "${element.alt}"`,
            playwrightSelector: `alt=${element.alt}`,
            confidence: 85,
            isStable: true,
            description: 'Alt text - Image accessibility',
        });
    }

    // 6. Title
    if (element.title) {
        candidates.push({
            strategy: 'title',
            selector: `title "${element.title}"`,
            playwrightSelector: `title=${element.title}`,
            confidence: 75,
            isStable: false,
            description: 'Title attribute',
        });
    }

    // 7. ID (if not auto-generated)
    if (element.id && !isAutoGeneratedId(element.id)) {
        candidates.push({
            strategy: 'id',
            selector: `#${element.id}`,
            playwrightSelector: `#${element.id}`,
            confidence: 70,
            isStable: false, // IDs may be auto-generated
            description: 'ID attribute',
        });
    }

    // 8. Text content (if short)
    if (element.innerText && element.innerText.length <= 50) {
        const text = element.innerText.trim();
        if (text) {
            candidates.push({
                strategy: 'text',
                selector: `text "${text}"`,
                playwrightSelector: `text="${text}"`,
                confidence: 60,
                isStable: false, // Text can change with i18n
                description: 'Text content - May change with localization',
            });
        }
    }

    // 9. CSS selector as last resort
    const cssSelector = buildCssSelector(element);
    if (cssSelector) {
        candidates.push({
            strategy: 'css',
            selector: cssSelector,
            playwrightSelector: cssSelector,
            confidence: 40,
            isStable: false,
            description: 'CSS Selector - May break with UI changes',
        });
    }

    // Sort by confidence (highest first)
    candidates.sort((a, b) => b.confidence - a.confidence);

    // Build resilient selector
    const primary = candidates[0] || {
        strategy: 'css' as const,
        selector: element.tagName.toLowerCase(),
        playwrightSelector: element.tagName.toLowerCase(),
        confidence: 20,
        isStable: false,
        description: 'Fallback tag selector',
    };

    const fallbacks = candidates.slice(1);

    // Calculate overall confidence
    const overallConfidence = primary.confidence;

    // Consider reliable if primary is stable or has good fallbacks
    const isReliable = primary.isStable ||
        (primary.confidence >= 70 && fallbacks.some(f => f.isStable));

    // Build fingerprint
    const fingerprint = buildFingerprint(element);

    return {
        primary,
        fallbacks,
        fingerprint,
        overallConfidence,
        isReliable,
    };
}

/**
 * Convert Playwright selector to Vero selector format
 */
export function playwrightToVeroSelector(playwright: string): string {
    // getByTestId('login-btn') -> testId "login-btn"
    let match = playwright.match(/getByTestId\(['"](.+?)['"]\)/);
    if (match) return `testId "${match[1]}"`;

    // getByRole('button', { name: 'Submit' }) -> button "Submit"
    match = playwright.match(/getByRole\(['"](\w+)['"](?:,\s*\{\s*name:\s*['"](.+?)['"]\s*\})?\)/);
    if (match) return match[2] ? `${match[1]} "${match[2]}"` : `role "${match[1]}"`;

    // getByLabel('Email') -> label "Email"
    match = playwright.match(/getByLabel\(['"](.+?)['"]\)/);
    if (match) return `label "${match[1]}"`;

    // getByPlaceholder('Enter name') -> placeholder "Enter name"
    match = playwright.match(/getByPlaceholder\(['"](.+?)['"]\)/);
    if (match) return `placeholder "${match[1]}"`;

    // getByText('Click me') -> text "Click me"
    match = playwright.match(/getByText\(['"](.+?)['"]\)/);
    if (match) return `text "${match[1]}"`;

    // getByAltText('Logo') -> alt "Logo"
    match = playwright.match(/getByAltText\(['"](.+?)['"]\)/);
    if (match) return `alt "${match[1]}"`;

    // getByTitle('Tooltip') -> title "Tooltip"
    match = playwright.match(/getByTitle\(['"](.+?)['"]\)/);
    if (match) return `title "${match[1]}"`;

    // locator('#id') or locator('.class') -> #id or .class
    match = playwright.match(/locator\(['"](.+?)['"]\)/);
    if (match) return match[1];

    return playwright;
}

/**
 * Get the stability score for a selector type
 */
export function getSelectorStability(strategy: string): number {
    return SELECTOR_STABILITY[strategy] || 0;
}

/**
 * Infer ARIA role from element tag and attributes
 */
function inferRole(element: CapturedElement): string | null {
    const tag = element.tagName.toLowerCase();
    const type = element.type?.toLowerCase();

    const roleMap: Record<string, string> = {
        'button': 'button',
        'a': 'link',
        'textarea': 'textbox',
        'select': 'combobox',
        'img': 'img',
        'nav': 'navigation',
        'dialog': 'dialog',
    };

    // Check for input type specific roles
    if (tag === 'input') {
        if (type === 'button' || type === 'submit') return 'button';
        if (type === 'checkbox') return 'checkbox';
        if (type === 'radio') return 'radio';
        if (type === 'text' || type === 'email' || type === 'password') return 'textbox';
        if (type === 'search') return 'searchbox';
    }

    return roleMap[tag] || null;
}

/**
 * Check if an ID looks auto-generated
 */
function isAutoGeneratedId(id: string): boolean {
    const autoGenPatterns = [
        /^[a-f0-9]{8,}/i,           // UUID-like
        /^[a-z]+_\d+$/i,            // prefix_number
        /^\d+$/,                     // Just numbers
        /^ember\d+/,                // Ember
        /^react-/i,                 // React
        /^ng-/i,                    // Angular
        /^vue-/i,                   // Vue
        /^:r\d+:/,                  // React 18+
        /^_[a-z0-9]+$/i,            // Underscore prefix
    ];

    return autoGenPatterns.some(pattern => pattern.test(id));
}

/**
 * Build a simple CSS selector for an element
 */
function buildCssSelector(element: CapturedElement): string {
    const parts: string[] = [];
    parts.push(element.tagName.toLowerCase());

    if (element.className) {
        const firstClass = element.className.split(' ')[0];
        if (firstClass && !isAutoGeneratedId(firstClass)) {
            parts.push(`.${firstClass}`);
        }
    }

    if (element.type) {
        parts.push(`[type="${element.type}"]`);
    }

    if (element.name) {
        parts.push(`[name="${element.name}"]`);
    }

    return parts.join('');
}

/**
 * Build element fingerprint for recovery
 */
function buildFingerprint(element: CapturedElement): ElementFingerprint {
    return {
        tagName: element.tagName,
        boundingBox: element.boundingBox,
        textContent: element.innerText?.slice(0, 100),
    };
}

/**
 * Convert array of fallback selectors to JSON for storage
 */
export function serializeFallbacks(selectors: SelectorCandidate[]): string {
    return JSON.stringify(selectors.map(s => ({
        strategy: s.strategy,
        selector: s.selector,
        confidence: s.confidence,
        isStable: s.isStable,
    })));
}

/**
 * Parse fallback selectors from JSON storage
 */
export function deserializeFallbacks(json: string): SelectorCandidate[] {
    try {
        const data = JSON.parse(json);
        return data.map((s: any) => ({
            strategy: s.strategy,
            selector: s.selector,
            playwrightSelector: s.selector, // Use same for now
            confidence: s.confidence,
            isStable: s.isStable,
        }));
    } catch {
        return [];
    }
}
