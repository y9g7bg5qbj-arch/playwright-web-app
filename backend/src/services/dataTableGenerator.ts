/**
 * Data Table Generator Service
 *
 * Generates TypeScript interfaces and data classes from data table schemas.
 * This enables type-safe access to test data in Vero scripts using the new
 * ROW/ROWS project-scoped syntax.
 *
 * Directory Structure:
 * vero-projects/
 * ├── ProjectA/
 * │   └── generated/
 * │       └── data/
 * │           ├── Users.ts        # Interface
 * │           ├── Products.ts     # Interface
 * │           └── ProjectAData.ts # Data class
 * ├── ProjectB/
 * │   └── generated/
 * │       └── data/
 * │           └── ProjectBData.ts
 */

import * as fs from 'fs';
import * as path from 'path';

export interface ReferenceConfig {
    targetSheet: string;
    targetColumn: string;
    displayColumn: string;
    allowMultiple: boolean;
    separator?: string;
}

export interface DataTableColumn {
    name: string;
    type: 'string' | 'number' | 'boolean' | 'date' | 'object' | 'array' | 'reference';
    nullable?: boolean;
    description?: string;
    referenceConfig?: ReferenceConfig;
}

export interface DataTableSchema {
    name: string;
    columns: DataTableColumn[];
    data?: Record<string, unknown>[];
}

export interface GeneratorOptions {
    projectId: string;
    projectName: string;
    outputDir: string;
}

export class DataTableGenerator {
    private options: GeneratorOptions;

    constructor(options: GeneratorOptions) {
        this.options = options;
    }

    /**
     * Generate TypeScript interface for a single data table
     */
    generateInterface(schema: DataTableSchema): string {
        const lines: string[] = [];
        const interfaceName = this.toInterfaceName(schema.name);

        lines.push(`/**`);
        lines.push(` * Generated interface for ${schema.name} data table`);
        lines.push(` * Auto-generated by Vero IDE - do not edit manually`);
        lines.push(` */`);
        lines.push(`export interface ${interfaceName} {`);

        for (const column of schema.columns) {
            const tsType = this.columnTypeToTS(column);
            const optional = column.nullable ? '?' : '';
            const comment = column.description ? ` // ${column.description}` : '';
            lines.push(`    ${column.name}${optional}: ${tsType};${comment}`);
        }

        lines.push(`}`);
        lines.push('');

        return lines.join('\n');
    }

    /**
     * Generate the project data class that provides typed access to all tables
     */
    generateDataClass(schemas: DataTableSchema[]): string {
        const lines: string[] = [];
        const className = `${this.options.projectName}Data`;

        lines.push(`/**`);
        lines.push(` * Generated data access class for ${this.options.projectName} project`);
        lines.push(` * Provides typed access to all test data tables`);
        lines.push(` * Auto-generated by Vero IDE - do not edit manually`);
        lines.push(` */`);
        lines.push('');

        // Import interfaces
        for (const schema of schemas) {
            const interfaceName = this.toInterfaceName(schema.name);
            lines.push(`import { ${interfaceName} } from './${schema.name}';`);
        }

        // Import data files
        lines.push('');
        for (const schema of schemas) {
            const dataFileName = this.toDataFileName(schema.name);
            lines.push(`import ${dataFileName} from '../data/${dataFileName}.json';`);
        }

        lines.push('');

        // Generate schema metadata for reference resolution
        lines.push(`// Schema metadata for reference resolution`);
        lines.push(`interface ReferenceConfig {`);
        lines.push(`    targetSheet: string;`);
        lines.push(`    targetColumn: string;`);
        lines.push(`    displayColumn: string;`);
        lines.push(`    allowMultiple: boolean;`);
        lines.push(`    separator?: string;`);
        lines.push(`}`);
        lines.push('');
        lines.push(`interface ColumnSchema {`);
        lines.push(`    name: string;`);
        lines.push(`    type: string;`);
        lines.push(`    referenceConfig?: ReferenceConfig;`);
        lines.push(`}`);
        lines.push('');
        lines.push(`const _schemas: Record<string, ColumnSchema[]> = {`);
        for (const schema of schemas) {
            lines.push(`    ${schema.name}: ${JSON.stringify(schema.columns.map(c => ({
                name: c.name,
                type: c.type,
                ...(c.referenceConfig ? { referenceConfig: c.referenceConfig } : {})
            })))},`);
        }
        lines.push(`};`);
        lines.push('');

        lines.push(`export class ${className} {`);

        // Static typed arrays for each table
        for (const schema of schemas) {
            const interfaceName = this.toInterfaceName(schema.name);
            const dataFileName = this.toDataFileName(schema.name);
            lines.push(`    static ${schema.name}: ${interfaceName}[] = ${dataFileName} as ${interfaceName}[];`);
        }

        lines.push('');
        lines.push(`    /**`);
        lines.push(`     * Resolve reference columns for a row, expanding foreign key IDs to full objects`);
        lines.push(`     * @param tableName - The source table name`);
        lines.push(`     * @param row - The row to resolve references for`);
        lines.push(`     * @returns The row with reference columns expanded to full objects`);
        lines.push(`     */`);
        lines.push(`    static resolveReferences<T extends Record<string, any>>(tableName: string, row: T): T & Record<string, any> {`);
        lines.push(`        if (!row) return row;`);
        lines.push(`        const schema = _schemas[tableName];`);
        lines.push(`        if (!schema) return row;`);
        lines.push('');
        lines.push(`        const resolved = { ...row } as T & Record<string, any>;`);
        lines.push('');
        lines.push(`        for (const col of schema) {`);
        lines.push(`            if (col.type === 'reference' && col.referenceConfig) {`);
        lines.push(`                const refConfig = col.referenceConfig;`);
        lines.push(`                const value = row[col.name];`);
        lines.push(`                if (!value) continue;`);
        lines.push('');
        lines.push(`                // Get target table data`);
        lines.push(`                const targetData = (${className} as any)[refConfig.targetSheet] as any[];`);
        lines.push(`                if (!targetData) continue;`);
        lines.push('');
        lines.push(`                // Parse IDs (comma-separated for multiple)`);
        lines.push(`                const separator = refConfig.separator || ',';`);
        lines.push(`                const ids = String(value).split(separator).map(id => id.trim()).filter(Boolean);`);
        lines.push('');
        lines.push(`                // Find matching rows`);
        lines.push(`                const matched = targetData.filter(r => ids.includes(String(r[refConfig.targetColumn])));`);
        lines.push('');
        lines.push(`                // Replace the ID(s) with the resolved object(s)`);
        lines.push(`                resolved[col.name] = refConfig.allowMultiple ? matched : matched[0] || null;`);
        lines.push(`            }`);
        lines.push(`        }`);
        lines.push('');
        lines.push(`        return resolved;`);
        lines.push(`    }`);
        lines.push('');
        lines.push(`    /**`);
        lines.push(`     * Resolve references for multiple rows`);
        lines.push(`     */`);
        lines.push(`    static resolveReferencesMany<T extends Record<string, any>>(tableName: string, rows: T[]): (T & Record<string, any>)[] {`);
        lines.push(`        return rows.map(row => ${className}.resolveReferences(tableName, row));`);
        lines.push(`    }`);

        lines.push(`}`);
        lines.push('');

        // Export as Data for default project context
        lines.push(`// Default export for current project context`);
        lines.push(`export const Data = ${className};`);
        lines.push('');

        return lines.join('\n');
    }

    /**
     * Generate all TypeScript files for a project's data tables
     */
    async generateAll(schemas: DataTableSchema[]): Promise<void> {
        const outputDir = path.join(this.options.outputDir, 'generated', 'data');

        // Ensure output directory exists
        await fs.promises.mkdir(outputDir, { recursive: true });

        // Generate interface files
        for (const schema of schemas) {
            const interfaceCode = this.generateInterface(schema);
            const filePath = path.join(outputDir, `${schema.name}.ts`);
            await fs.promises.writeFile(filePath, interfaceCode, 'utf-8');
        }

        // Generate data class
        const dataClassCode = this.generateDataClass(schemas);
        const dataClassPath = path.join(outputDir, `${this.options.projectName}Data.ts`);
        await fs.promises.writeFile(dataClassPath, dataClassCode, 'utf-8');

        // Generate index file
        const indexCode = this.generateIndex(schemas);
        const indexPath = path.join(outputDir, 'index.ts');
        await fs.promises.writeFile(indexPath, indexCode, 'utf-8');
    }

    /**
     * Generate index file that exports all types and data
     */
    private generateIndex(schemas: DataTableSchema[]): string {
        const lines: string[] = [];
        const className = `${this.options.projectName}Data`;

        lines.push(`// Generated index for ${this.options.projectName} data`);
        lines.push('');

        // Export interfaces
        for (const schema of schemas) {
            const interfaceName = this.toInterfaceName(schema.name);
            lines.push(`export { ${interfaceName} } from './${schema.name}';`);
        }

        lines.push('');
        lines.push(`export { ${className}, Data } from './${className}';`);
        lines.push('');

        return lines.join('\n');
    }

    /**
     * Infer schema from data (for cases where schema is not explicitly defined)
     */
    inferSchemaFromData(tableName: string, data: Record<string, unknown>[]): DataTableSchema {
        if (data.length === 0) {
            return { name: tableName, columns: [] };
        }

        const columns: DataTableColumn[] = [];
        const firstRow = data[0];

        for (const [key, value] of Object.entries(firstRow)) {
            const type = this.inferColumnType(value);
            columns.push({
                name: key,
                type,
                nullable: data.some(row => row[key] === null || row[key] === undefined)
            });
        }

        return { name: tableName, columns, data };
    }

    /**
     * Convert column type to TypeScript type
     */
    private columnTypeToTS(column: DataTableColumn): string {
        const typeMap: Record<string, string> = {
            'string': 'string',
            'number': 'number',
            'boolean': 'boolean',
            'date': 'Date',
            'object': 'Record<string, unknown>',
            'array': 'unknown[]'
        };

        return typeMap[column.type] || 'unknown';
    }

    /**
     * Infer column type from value
     */
    private inferColumnType(value: unknown): DataTableColumn['type'] {
        if (value === null || value === undefined) {
            return 'string'; // Default to string for null values
        }

        if (typeof value === 'string') {
            // Check if it's a date string
            if (/^\d{4}-\d{2}-\d{2}/.test(value)) {
                return 'date';
            }
            return 'string';
        }

        if (typeof value === 'number') {
            return 'number';
        }

        if (typeof value === 'boolean') {
            return 'boolean';
        }

        if (Array.isArray(value)) {
            return 'array';
        }

        if (typeof value === 'object') {
            return 'object';
        }

        return 'string';
    }

    /**
     * Convert table name to interface name (PascalCase singular)
     */
    private toInterfaceName(tableName: string): string {
        // Remove trailing 's' for plural -> singular
        let name = tableName;
        if (name.endsWith('s') && !name.endsWith('ss')) {
            name = name.slice(0, -1);
        }

        // Ensure PascalCase
        return name.charAt(0).toUpperCase() + name.slice(1);
    }

    /**
     * Convert table name to data file name (camelCase)
     */
    private toDataFileName(tableName: string): string {
        return tableName.charAt(0).toLowerCase() + tableName.slice(1);
    }
}

/**
 * Factory function to create a generator for a specific project
 */
export function createDataTableGenerator(
    projectId: string,
    projectName: string,
    baseOutputDir: string
): DataTableGenerator {
    const outputDir = path.join(baseOutputDir, projectId);
    return new DataTableGenerator({
        projectId,
        projectName,
        outputDir
    });
}

/**
 * Generate data files for a project when tables are saved
 */
export async function regenerateProjectData(
    projectId: string,
    projectName: string,
    tables: Array<{ name: string; data: Record<string, unknown>[] }>,
    baseOutputDir: string
): Promise<void> {
    const generator = createDataTableGenerator(projectId, projectName, baseOutputDir);

    const schemas = tables.map(table =>
        generator.inferSchemaFromData(table.name, table.data)
    );

    await generator.generateAll(schemas);
}
