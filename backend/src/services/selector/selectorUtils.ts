/**
 * Selector Utilities - Parsing, normalization, and name generation helpers
 *
 * Provides selector value parsing, normalization for comparison,
 * auto-generated value detection, CSS selector building, and
 * string case conversion utilities. Used by PageObjectRegistry.
 */

// Selector type union, kept in sync with PageField['selectorType'] in pageObjectRegistry.ts
type SelectorType = 'testid' | 'role' | 'label' | 'placeholder' | 'text' | 'id' | 'css';

// Minimal element info needed by buildCssSelector, kept in sync with ElementInfo in pageObjectRegistry.ts
interface ElementInfoForCss {
    tagName: string;
    className?: string;
    inputType?: string;
}

/**
 * Parse a selector value to determine its type and extract raw value
 */
export function parseSelectorValue(value: string): { type: SelectorType; rawValue: string } {
    // testId "value"
    const testIdMatch = value.match(/^testId\s+"([^"]+)"$/i);
    if (testIdMatch) return { type: 'testid', rawValue: testIdMatch[1] };

    // role "button" name "Submit" or just button "Submit"
    const roleMatch = value.match(/^(?:role\s+")?(\w+)"\s+(?:name\s+)?"([^"]+)"$/i);
    if (roleMatch) return { type: 'role', rawValue: `${roleMatch[1]}:${roleMatch[2]}` };

    // button "Submit" (shorthand)
    const buttonMatch = value.match(/^button\s+"([^"]+)"$/i);
    if (buttonMatch) return { type: 'role', rawValue: `button:${buttonMatch[1]}` };

    // link "Click here"
    const linkMatch = value.match(/^link\s+"([^"]+)"$/i);
    if (linkMatch) return { type: 'role', rawValue: `link:${linkMatch[1]}` };

    // TEXTBOX "Email" (legacy format - maps to label)
    const textboxMatch = value.match(/^textbox\s+"([^"]+)"$/i);
    if (textboxMatch) return { type: 'label', rawValue: textboxMatch[1] };

    // label "Username"
    const labelMatch = value.match(/^label\s+"([^"]+)"$/i);
    if (labelMatch) return { type: 'label', rawValue: labelMatch[1] };

    // placeholder "Enter email"
    const placeholderMatch = value.match(/^placeholder\s+"([^"]+)"$/i);
    if (placeholderMatch) return { type: 'placeholder', rawValue: placeholderMatch[1] };

    // text "Click me"
    const textMatch = value.match(/^text\s+"([^"]+)"$/i);
    if (textMatch) return { type: 'text', rawValue: textMatch[1] };

    // "Simple text selector"
    const simpleTextMatch = value.match(/^"([^"]+)"$/);
    if (simpleTextMatch) return { type: 'text', rawValue: simpleTextMatch[1] };

    // #id or .class or complex CSS
    if (value.startsWith('#')) return { type: 'id', rawValue: value.slice(1) };
    if (value.startsWith('.') || value.includes('[')) return { type: 'css', rawValue: value };

    return { type: 'css', rawValue: value };
}

/**
 * Normalize a selector for comparison
 */
export function normalizeSelector(selector: string): string {
    return selector
        .toLowerCase()
        .replace(/\s+/g, ' ')
        .trim();
}

/**
 * Check if a value looks auto-generated (random/hash-like)
 */
export function isAutoGenerated(value: string): boolean {
    // Check for common auto-generated patterns
    const autoGenPatterns = [
        /^[a-f0-9]{8,}$/i,           // Hex hashes
        /^[a-z]{1,3}[0-9a-f]{6,}$/i, // Prefixed hashes (e.g., "r1a2b3c4")
        /^:r[0-9a-z]+:$/,            // React IDs
        /^sc-[a-z]+$/i,              // Styled-components
        /^css-[a-z0-9]+$/i,          // CSS modules
        /^ember\d+$/,                // Ember
        /^ng-[a-z]+-\d+$/,           // Angular
        /__[a-z]+_\d+$/i,            // BEM-like generated
    ];

    return autoGenPatterns.some(pattern => pattern.test(value));
}

/**
 * Build a CSS selector from element info
 */
export function buildCssSelector(element: ElementInfoForCss): string {
    const parts: string[] = [element.tagName.toLowerCase()];

    if (element.className) {
        const classes = element.className.split(/\s+/).filter(c => !isAutoGenerated(c));
        if (classes.length > 0) {
            parts.push(`.${classes[0]}`);
        }
    }

    if (element.inputType) {
        parts.push(`[type="${element.inputType}"]`);
    }

    return parts.join('');
}

/**
 * Convert a string to camelCase
 */
export function toCamelCase(str: string): string {
    return str
        .replace(/[^a-zA-Z0-9\s]/g, ' ')
        .trim()
        .split(/\s+/)
        .map((word, i) => {
            if (i === 0) return word.toLowerCase();
            return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
        })
        .join('');
}

/**
 * Convert a string to PascalCase
 */
export function toPascalCase(str: string): string {
    return str
        .replace(/[^a-zA-Z0-9\s]/g, ' ')
        .trim()
        .split(/\s+/)
        .filter(Boolean)
        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
        .join('');
}
