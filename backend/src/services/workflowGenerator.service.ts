/**
 * GitHub Actions Workflow Generator Service
 * Generates workflow YAML files for Playwright test execution
 */

import type {
  RunConfiguration,
  GitHubActionsConfig,
  ArtifactMode,
  BrowserType,
  BrowserChannel,
} from '@playwright-web-app/shared';

interface WorkflowGeneratorOptions {
  name?: string;
  description?: string;
  triggers?: {
    push?: { branches?: string[] };
    pullRequest?: { branches?: string[] };
    schedule?: string[]; // Cron expressions
    workflowDispatch?: boolean;
  };
  environment?: {
    name: string;
    baseUrl: string;
    variables?: Record<string, string>;
  };
}

interface GeneratedWorkflow {
  content: string;
  path: string;
  filename: string;
}

class WorkflowGeneratorService {
  /**
   * Generate a complete GitHub Actions workflow file
   */
  generateWorkflow(
    config: Partial<RunConfiguration>,
    options: WorkflowGeneratorOptions = {}
  ): GeneratedWorkflow {
    const workflowName = options.name || 'Vero Playwright Tests';
    const githubConfig = config.githubActionsConfig || {
      runnerType: 'cloud-hosted',
      shardCount: 1,
      workersPerShard: 1,
    };

    const lines: string[] = [];

    // Header comment
    lines.push('# Generated by Vero IDE');
    lines.push('# https://vero-ide.com');
    lines.push('');
    lines.push(`name: ${workflowName}`);
    lines.push('');

    // Triggers
    lines.push(...this.generateTriggers(options.triggers));
    lines.push('');

    // Environment variables
    if (options.environment) {
      lines.push('env:');
      lines.push(`  BASE_URL: ${options.environment.baseUrl}`);
      if (options.environment.variables) {
        for (const [key, value] of Object.entries(options.environment.variables)) {
          lines.push(`  ${key}: ${value}`);
        }
      }
      lines.push('');
    }

    // Jobs
    lines.push('jobs:');
    lines.push(...this.generateTestJob(config, githubConfig));

    // Merge reports job (if sharding)
    if (githubConfig.shardCount > 1) {
      lines.push('');
      lines.push(...this.generateMergeReportsJob(githubConfig));
    }

    return {
      content: lines.join('\n'),
      path: '.github/workflows',
      filename: 'vero-tests.yml',
    };
  }

  /**
   * Generate trigger configuration
   */
  private generateTriggers(triggers?: WorkflowGeneratorOptions['triggers']): string[] {
    const lines: string[] = [];

    if (!triggers) {
      // Default triggers
      lines.push('on:');
      lines.push('  push:');
      lines.push('    branches: [main, master]');
      lines.push('  pull_request:');
      lines.push('    branches: [main, master]');
      lines.push('  workflow_dispatch:');
      lines.push('    inputs:');
      lines.push('      environment:');
      lines.push("        description: 'Target environment'");
      lines.push('        required: false');
      lines.push("        default: 'staging'");
      lines.push("        type: choice");
      lines.push('        options:');
      lines.push('          - staging');
      lines.push('          - production');
      lines.push('      config_id:');
      lines.push("        description: 'Run configuration ID (from Vero IDE)'");
      lines.push('        required: false');
      lines.push('        type: string');
      return lines;
    }

    lines.push('on:');

    if (triggers.push) {
      lines.push('  push:');
      if (triggers.push.branches) {
        lines.push(`    branches: [${triggers.push.branches.join(', ')}]`);
      }
    }

    if (triggers.pullRequest) {
      lines.push('  pull_request:');
      if (triggers.pullRequest.branches) {
        lines.push(`    branches: [${triggers.pullRequest.branches.join(', ')}]`);
      }
    }

    if (triggers.schedule && triggers.schedule.length > 0) {
      lines.push('  schedule:');
      for (const cron of triggers.schedule) {
        lines.push(`    - cron: '${cron}'`);
      }
    }

    if (triggers.workflowDispatch !== false) {
      lines.push('  workflow_dispatch:');
      lines.push('    inputs:');
      lines.push('      environment:');
      lines.push("        description: 'Target environment'");
      lines.push('        required: false');
      lines.push("        default: 'staging'");
      lines.push('      config_id:');
      lines.push("        description: 'Run configuration ID'");
      lines.push('        required: false');
    }

    return lines;
  }

  /**
   * Generate the main test job
   */
  private generateTestJob(
    config: Partial<RunConfiguration>,
    githubConfig: GitHubActionsConfig
  ): string[] {
    const lines: string[] = [];
    const indent = '  ';

    lines.push(`${indent}test:`);

    // Timeout
    const timeoutMinutes = githubConfig.timeoutMinutes || 60;
    lines.push(`${indent}  timeout-minutes: ${timeoutMinutes}`);

    // Runner
    if (githubConfig.runnerType === 'self-hosted') {
      const labels = githubConfig.runnerLabels || ['self-hosted', 'linux', 'x64'];
      lines.push(`${indent}  runs-on: [${labels.join(', ')}]`);
    } else {
      lines.push(`${indent}  runs-on: ubuntu-latest`);
    }

    // Strategy (sharding)
    if (githubConfig.shardCount > 1) {
      lines.push(`${indent}  strategy:`);
      lines.push(`${indent}    fail-fast: ${githubConfig.continueOnError ? 'false' : 'true'}`);
      lines.push(`${indent}    matrix:`);
      const shards = Array.from({ length: githubConfig.shardCount }, (_, i) => i + 1);
      lines.push(`${indent}      shard: [${shards.join(', ')}]`);
    }

    // Steps
    lines.push(`${indent}  steps:`);

    // Checkout
    lines.push(`${indent}    - uses: actions/checkout@v4`);

    // Setup Node.js
    lines.push(`${indent}    - uses: actions/setup-node@v4`);
    lines.push(`${indent}      with:`);
    lines.push(`${indent}        node-version: 20`);
    lines.push(`${indent}        cache: 'npm'`);

    // Install dependencies
    lines.push(`${indent}    - name: Install dependencies`);
    lines.push(`${indent}      run: npm ci`);

    // Install Playwright browsers
    lines.push(`${indent}    - name: Install Playwright browsers`);
    const browser = config.browser || 'chromium';
    const browserInstall = this.getBrowserInstallCommand(browser, config.browserChannel);
    lines.push(`${indent}      run: ${browserInstall}`);

    // Run tests
    lines.push(`${indent}    - name: Run Playwright tests`);
    lines.push(`${indent}      run: |`);

    const testCommand = this.buildTestCommand(config, githubConfig);
    lines.push(`${indent}        ${testCommand}`);

    // Environment variables for the test step
    lines.push(`${indent}      env:`);
    lines.push(`${indent}        CI: true`);
    if (config.retries) {
      lines.push(`${indent}        PLAYWRIGHT_RETRIES: ${config.retries}`);
    }

    // Upload test results
    lines.push(`${indent}    - name: Upload test results`);
    lines.push(`${indent}      uses: actions/upload-artifact@v4`);
    lines.push(`${indent}      if: always()`);
    lines.push(`${indent}      with:`);

    if (githubConfig.shardCount > 1) {
      lines.push(`${indent}        name: test-results-\${{ matrix.shard }}`);
    } else {
      lines.push(`${indent}        name: test-results`);
    }
    lines.push(`${indent}        path: |`);
    lines.push(`${indent}          test-results/`);
    lines.push(`${indent}          playwright-report/`);
    lines.push(`${indent}        retention-days: 30`);

    // Upload blob report for sharding
    if (githubConfig.shardCount > 1) {
      lines.push(`${indent}    - name: Upload blob report`);
      lines.push(`${indent}      uses: actions/upload-artifact@v4`);
      lines.push(`${indent}      if: always()`);
      lines.push(`${indent}      with:`);
      lines.push(`${indent}        name: blob-report-\${{ matrix.shard }}`);
      lines.push(`${indent}        path: blob-report/`);
      lines.push(`${indent}        retention-days: 7`);
    }

    return lines;
  }

  /**
   * Generate the merge reports job (for sharded runs)
   */
  private generateMergeReportsJob(githubConfig: GitHubActionsConfig): string[] {
    const lines: string[] = [];
    const indent = '  ';

    lines.push(`${indent}merge-reports:`);
    lines.push(`${indent}  if: always()`);
    lines.push(`${indent}  needs: [test]`);
    lines.push(`${indent}  runs-on: ubuntu-latest`);
    lines.push(`${indent}  steps:`);

    // Download all blob reports
    lines.push(`${indent}    - uses: actions/checkout@v4`);
    lines.push(`${indent}    - uses: actions/setup-node@v4`);
    lines.push(`${indent}      with:`);
    lines.push(`${indent}        node-version: 20`);

    lines.push(`${indent}    - name: Download blob reports`);
    lines.push(`${indent}      uses: actions/download-artifact@v4`);
    lines.push(`${indent}      with:`);
    lines.push(`${indent}        pattern: blob-report-*`);
    lines.push(`${indent}        path: all-blob-reports`);
    lines.push(`${indent}        merge-multiple: true`);

    // Merge reports
    lines.push(`${indent}    - name: Merge reports`);
    lines.push(`${indent}      run: |`);
    lines.push(`${indent}        npm ci`);
    lines.push(`${indent}        npx playwright merge-reports --reporter html ./all-blob-reports`);

    // Upload merged report
    lines.push(`${indent}    - name: Upload merged HTML report`);
    lines.push(`${indent}      uses: actions/upload-artifact@v4`);
    lines.push(`${indent}      with:`);
    lines.push(`${indent}        name: playwright-report`);
    lines.push(`${indent}        path: playwright-report/`);
    lines.push(`${indent}        retention-days: 30`);

    return lines;
  }

  /**
   * Get browser install command
   */
  private getBrowserInstallCommand(browser: BrowserType, channel?: BrowserChannel): string {
    if (channel) {
      // For branded browsers like Chrome or Edge
      return `npx playwright install --with-deps ${browser}`;
    }
    return `npx playwright install --with-deps ${browser}`;
  }

  /**
   * Build the playwright test command
   */
  private buildTestCommand(
    config: Partial<RunConfiguration>,
    githubConfig: GitHubActionsConfig
  ): string {
    const parts: string[] = ['npx playwright test'];

    // Sharding
    if (githubConfig.shardCount > 1) {
      parts.push(`--shard=\${{ matrix.shard }}/${githubConfig.shardCount}`);
    }

    // Workers
    if (githubConfig.workersPerShard && githubConfig.workersPerShard > 1) {
      parts.push(`--workers=${githubConfig.workersPerShard}`);
    }

    // Browser project
    if (config.browser && config.browser !== 'chromium') {
      parts.push(`--project=${config.browser}`);
    }

    // Retries
    if (config.retries && config.retries > 0) {
      parts.push(`--retries=${config.retries}`);
    }

    // Timeout
    if (config.timeout && config.timeout !== 30000) {
      parts.push(`--timeout=${config.timeout}`);
    }

    // Grep filter
    if (config.grep) {
      parts.push(`--grep="${config.grep}"`);
    }

    // Reporter for sharding (use blob reporter)
    if (githubConfig.shardCount > 1) {
      parts.push('--reporter=blob');
    }

    return parts.join(' ');
  }

  /**
   * Generate a complete workflow with all options exposed
   */
  generateAdvancedWorkflow(
    config: RunConfiguration,
    options: WorkflowGeneratorOptions & {
      nodeVersion?: string;
      playwrightVersion?: string;
      additionalSteps?: Array<{ name: string; run: string }>;
    }
  ): GeneratedWorkflow {
    // Use the basic generator as a starting point
    const basic = this.generateWorkflow(config, options);

    // For now, return the basic workflow
    // In the future, we can add more customization here
    return basic;
  }

  /**
   * Validate a workflow configuration
   */
  validateConfig(config: Partial<RunConfiguration>): { valid: boolean; errors: string[] } {
    const errors: string[] = [];

    if (config.target !== 'github-actions') {
      errors.push('Configuration target must be "github-actions"');
    }

    const githubConfig = config.githubActionsConfig;
    if (!githubConfig) {
      errors.push('Missing GitHub Actions configuration');
      return { valid: false, errors };
    }

    if (githubConfig.shardCount < 1 || githubConfig.shardCount > 50) {
      errors.push('Shard count must be between 1 and 50');
    }

    if (githubConfig.workersPerShard < 1 || githubConfig.workersPerShard > 10) {
      errors.push('Workers per shard must be between 1 and 10');
    }

    if (githubConfig.runnerType === 'self-hosted' && !githubConfig.runnerLabels?.length) {
      errors.push('Self-hosted runners require at least one label');
    }

    return { valid: errors.length === 0, errors };
  }

  /**
   * Estimate execution time
   */
  estimateExecutionTime(
    testCount: number,
    avgTestDurationSeconds: number,
    config: GitHubActionsConfig
  ): { minutes: number; formatted: string } {
    const totalTestTime = testCount * avgTestDurationSeconds;
    const parallelBrowsers = config.shardCount * config.workersPerShard;
    const estimatedSeconds = totalTestTime / parallelBrowsers;

    // Add overhead for setup (npm install, browser install, etc.)
    const setupOverhead = config.runnerType === 'self-hosted' ? 30 : 120; // Self-hosted has less cold start
    const totalSeconds = estimatedSeconds + setupOverhead;

    const minutes = Math.ceil(totalSeconds / 60);

    let formatted: string;
    if (minutes < 1) {
      formatted = 'Less than 1 minute';
    } else if (minutes === 1) {
      formatted = '~1 minute';
    } else if (minutes < 60) {
      formatted = `~${minutes} minutes`;
    } else {
      const hours = Math.floor(minutes / 60);
      const remainingMinutes = minutes % 60;
      formatted = `~${hours}h ${remainingMinutes}m`;
    }

    return { minutes, formatted };
  }
}

export const workflowGeneratorService = new WorkflowGeneratorService();
export default workflowGeneratorService;
