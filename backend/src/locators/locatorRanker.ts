// Locator Ranker
// Ranks locators by reliability for smart suggestions
// Used when recording to suggest the best locator strategies

import { RankedLocator } from '@playwright-web-app/shared';

/**
 * Locator priority rankings (lower = better)
 */
export const LOCATOR_PRIORITIES: Record<string, number> = {
    'testId': 1,      // Most reliable - explicit test hooks
    'role': 2,        // Semantic, accessibility-friendly
    'label': 3,       // Form associations
    'placeholder': 4, // Input hints
    'altText': 5,     // Image accessibility
    'title': 6,       // Title attributes
    'text': 7,        // Visible text (can change)
    'id': 8,          // ID attributes (may be auto-generated)
    'css': 9,         // CSS selectors (fragile)
    'xpath': 10,      // XPath (most fragile)
};

/**
 * Element information used for ranking
 */
export interface ElementInfo {
    tagName: string;
    id?: string;
    testId?: string;
    role?: string;
    ariaLabel?: string;
    innerText?: string;
    placeholder?: string;
    alt?: string;
    title?: string;
    className?: string;
    name?: string;
    type?: string;
    href?: string;
}

/**
 * Generate and rank all possible locators for an element
 */
export function rankLocators(element: ElementInfo): RankedLocator[] {
    const locators: RankedLocator[] = [];

    // 1. TestId (highest priority)
    if (element.testId) {
        locators.push({
            strategy: { type: 'testId', testId: element.testId },
            priority: LOCATOR_PRIORITIES.testId,
            confidence: 100,
            selector: `getByTestId('${element.testId}')`,
            description: 'Test ID - Most reliable, explicit test hook',
        });
    }

    // 2. Role with accessible name
    if (element.role || inferRole(element)) {
        const role = element.role || inferRole(element);
        const name = element.ariaLabel || element.innerText?.slice(0, 50);

        if (role) {
            locators.push({
                strategy: {
                    type: 'role',
                    role,
                    name: name || undefined,
                    exact: name ? false : undefined,
                },
                priority: LOCATOR_PRIORITIES.role,
                confidence: name ? 90 : 70,
                selector: `getByRole('${role}'${name ? `, { name: '${name}' }` : ''})`,
                description: 'ARIA Role - Semantic and accessibility-friendly',
            });
        }
    }

    // 3. Label (for form elements)
    if (element.ariaLabel) {
        locators.push({
            strategy: { type: 'label', label: element.ariaLabel },
            priority: LOCATOR_PRIORITIES.label,
            confidence: 85,
            selector: `getByLabel('${element.ariaLabel}')`,
            description: 'Label - Form element association',
        });
    }

    // 4. Placeholder
    if (element.placeholder) {
        locators.push({
            strategy: { type: 'placeholder', placeholder: element.placeholder },
            priority: LOCATOR_PRIORITIES.placeholder,
            confidence: 80,
            selector: `getByPlaceholder('${element.placeholder}')`,
            description: 'Placeholder - Input hint text',
        });
    }

    // 5. Alt text (for images)
    if (element.alt) {
        locators.push({
            strategy: { type: 'altText', altText: element.alt },
            priority: LOCATOR_PRIORITIES.altText,
            confidence: 85,
            selector: `getByAltText('${element.alt}')`,
            description: 'Alt text - Image accessibility text',
        });
    }

    // 6. Title
    if (element.title) {
        locators.push({
            strategy: { type: 'title', title: element.title },
            priority: LOCATOR_PRIORITIES.title,
            confidence: 75,
            selector: `getByTitle('${element.title}')`,
            description: 'Title attribute',
        });
    }

    // 7. Text content (if unique and short)
    if (element.innerText && element.innerText.length <= 100) {
        const text = element.innerText.trim();
        if (text) {
            locators.push({
                strategy: { type: 'text', text },
                priority: LOCATOR_PRIORITIES.text,
                confidence: 60,
                selector: `getByText('${text}')`,
                description: 'Text content - May change with localization',
            });
        }
    }

    // 8. ID (if not auto-generated)
    if (element.id && !isAutoGeneratedId(element.id)) {
        locators.push({
            strategy: { type: 'id', id: element.id },
            priority: LOCATOR_PRIORITIES.id,
            confidence: 70,
            selector: `locator('#${element.id}')`,
            description: 'ID attribute - May be auto-generated',
        });
    }

    // 9. CSS selector
    const cssSelector = buildCssSelector(element);
    if (cssSelector) {
        locators.push({
            strategy: { type: 'css', selector: cssSelector },
            priority: LOCATOR_PRIORITIES.css,
            confidence: 40,
            selector: `locator('${cssSelector}')`,
            description: 'CSS Selector - May break with UI changes',
        });
    }

    // Sort by priority (lower = better)
    return locators.sort((a, b) => a.priority - b.priority);
}

/**
 * Get the best locator for an element
 */
export function getBestLocator(element: ElementInfo): RankedLocator | null {
    const ranked = rankLocators(element);
    return ranked[0] || null;
}

/**
 * Get top N locators for an element
 */
export function getTopLocators(element: ElementInfo, count: number = 3): RankedLocator[] {
    const ranked = rankLocators(element);
    return ranked.slice(0, count);
}

/**
 * Infer ARIA role from element tag and attributes
 */
function inferRole(element: ElementInfo): string | null {
    const tag = element.tagName.toLowerCase();
    const type = element.type?.toLowerCase();

    // Common role mappings
    const roleMap: Record<string, string> = {
        'button': 'button',
        'a': 'link',
        'input[type=button]': 'button',
        'input[type=submit]': 'button',
        'input[type=checkbox]': 'checkbox',
        'input[type=radio]': 'radio',
        'input[type=text]': 'textbox',
        'input[type=email]': 'textbox',
        'input[type=password]': 'textbox',
        'input[type=search]': 'searchbox',
        'textarea': 'textbox',
        'select': 'combobox',
        'img': 'img',
        'nav': 'navigation',
        'main': 'main',
        'header': 'banner',
        'footer': 'contentinfo',
        'aside': 'complementary',
        'dialog': 'dialog',
        'table': 'table',
        'tr': 'row',
        'th': 'columnheader',
        'td': 'cell',
        'ul': 'list',
        'ol': 'list',
        'li': 'listitem',
        'h1': 'heading',
        'h2': 'heading',
        'h3': 'heading',
        'h4': 'heading',
        'h5': 'heading',
        'h6': 'heading',
    };

    // Check for input type specific roles
    if (tag === 'input' && type) {
        const key = `input[type=${type}]`;
        if (roleMap[key]) return roleMap[key];
    }

    return roleMap[tag] || null;
}

/**
 * Check if an ID looks auto-generated
 */
function isAutoGeneratedId(id: string): boolean {
    // Common patterns for auto-generated IDs
    const autoGenPatterns = [
        /^[a-f0-9]{8,}/i,           // UUID-like
        /^[a-z]+_\d+$/i,            // prefix_number
        /^\d+$/,                     // Just numbers
        /^ember\d+/,                // Ember
        /^react-/i,                 // React
        /^ng-/i,                    // Angular
        /^vue-/i,                   // Vue
        /^:r\d+:/,                  // React 18+
        /^_[a-z0-9]+$/i,            // Underscore prefix
    ];

    return autoGenPatterns.some(pattern => pattern.test(id));
}

/**
 * Build a simple CSS selector for an element
 */
function buildCssSelector(element: ElementInfo): string {
    const parts: string[] = [];

    // Tag name
    parts.push(element.tagName.toLowerCase());

    // Add class if present (first class only)
    if (element.className) {
        const firstClass = element.className.split(' ')[0];
        if (firstClass && !isAutoGeneratedId(firstClass)) {
            parts.push(`.${firstClass}`);
        }
    }

    // Add type for inputs
    if (element.type) {
        parts.push(`[type="${element.type}"]`);
    }

    // Add name attribute
    if (element.name) {
        parts.push(`[name="${element.name}"]`);
    }

    return parts.join('');
}
